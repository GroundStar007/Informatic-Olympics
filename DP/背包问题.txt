01背包
每种物品只有一件
阶段：枚举到哪一件物品
状态：f[i][j]表示枚举到第i件物品，恰好放入容量为j的背包中，所能获取的最大价值
指标函数：f[i][j]
状态变量：i j
决策：放或不放
策略：
状态转移方程：
转移：每一个转移对应一个决策
f[i][j] = max(f[i-1][j], f[i-1][v-c[i]] + w[i])

一维优化
从大到小枚举背包容积，保证计算f[i][j]时，所依赖的两个状态没有被新状态覆盖
指标函数：f[j]
f[j] = max{f[j], f[j - c[i]] + w[i]}


完全背包
每种物品有无数件
1.设k = v / c[i]，将第i件物品拆分为k件复制，每一件的花费和价值都和原物品相同
O(nV Σk)
2.设k = v / c[i]
将第i件物品拆分为log(k) + 1件复制，
k = 7   log(7) = 2   c[i]   w[i]
1   c[i]    w[i]     2^0倍
2   2*c[i]   2*w[i]  2^1倍
3   4*c[i]   4*w[i]  2^2倍
0-不放    1-1  2-2  3-1+2  4-3  5-1+3   6-2+3   7-1+2+3
3.一维优化
将01背包代码中倒序枚举v的做法改为正序枚举，会导致计算f[i][j]所依赖的状态之一 f[i - 1][j - c[i]]先被f[i][j - c[i]]覆盖；
f[i][j - c[i]]可能已经包含了选择物品i的决策；


多重背包
每种物品有复数件
设对于物品i，有k = v / c[i]
① n[i] > k 认为物品有无限件，作为完全背包处理
② n[i] <= k 二进制拆分物品，转化为01背包解决
③ n[i] = 0 