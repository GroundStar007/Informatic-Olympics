一、
①阶段：线性动态规划的阶段数量一般和序列长度相关
-按照枚举的下标划分阶段

二、
②指标函数：求谁设谁
-设最长不下降子序列的长度为指标函数f

③状态变量：当一个指标会影响到后续决策时，它应该出现在状态中，而不是决策中
-i 表示阶段
f[i]表示枚举到第i个数时已知的最长不下降子序列的长度
-j 表示已知的最长不下降子序列的最后一个数字
f[i][j]表示枚举到第i个数时、以j结尾的最长不下降子序列的长度

③*
-i 表示阶段
f[i]表示枚举到第i个数时已知的最长不下降子序列的长度
-j 表示已知的最长不下降子序列的最后一个元素在原序列中的下标
f[i][j]表示枚举到第i个数时、以a[j]结尾的最长不下降子序列的长度

三、
④决策：每个阶段可以采取的操作
-将第i个数选入不下降子序列
-不将第i个数选入不下降子序列

四、
⑤转移：每个转移对应一种决策
设第i个数为a[i]
-将第i个数选入不下降子序列
f[i][a[i]] = max{f[i - 1][k] | k <= a[i]}
假设不下降子序列为u
u[1], u[2], .... , u[m], a[i] 满足 u[m] <= a[i]
-不将第i个数选入不下降子序列
f[i][u[m]] = f[i - 1][u[m]]


⑤*
-将第i个数选入不下降子序列
f[i][i] = max{f[i - 1][k] | a[k] <= a[i], k < i}
-不将第i个数选入不下降子序列
f[i][k] = f[i - 1][k] | k < i


⑥状态转移方程：将状态转移组合在一起
f[i][a[i]] = max{f[i - 1][k] | k <= a[i]}
f[i][u[m]] = f[i - 1][u[m]]

⑥*
f[i][i] = max{f[i - 1][k] | a[k] <= a[i], k < i}
f[i][k] = f[i - 1][k] | k < i

五、
⑦初始化
f[i][a[i]] = 1
f[i][k] = 0 | k != a[i]

⑦*
f[i][i] = 1
f[i][k] = 0 | a[k] != a[i], k < i

六、
⑧统计答案
f[n][k] | k ∈ a

⑧*
f[n][k] | 1 <= k <= n


for(int i = 1; i <= n; ++ i)
{
	for(int j = 1; j <= i; ++ j)
	{
		int k = a[j];
		// f[i][a[i]] = max{f[i - 1][k] | k <= a[i]} + 1
		if(k <= a[i])
			f[i][a[i]] = max(f[i][a[i]], f[i - 1][k] + 1);
		// 不选
		f[i][a[j]] = f[i - 1][a[j]];
	}
}

